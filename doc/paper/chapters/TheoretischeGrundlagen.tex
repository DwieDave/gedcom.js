\chapter{Theoretische Grundlagen}
\label{chap: Theoretische Grundlagen}
In diesem Kapitel werden die theoretischen Grundlagen für das Verständnis dieser Projektarbeit beschrieben. Dazu wird eine kurze Einführung in Genealogie, FamilySearch und GEDCOM im speziellen gegeben, um ein Verständnis für die Thematik aufzubauen. Zudem wird auf mehrere Quellen verwiesen, aus denen tiefergehende Informationen erschlossen werden können. Im Anschluss dazu wird kurz auf die JavaScript Bibliothek \textit{Nearley} und das JavaScript Testframework \textit{Mocha} eingegangen, die für die Umsetzung dieser Projektarbeit relevant werden.

\section{Genealogie und FamilySearch}
\label{sec: Genealogie und FamilySearch}
Genealogie ist ein Überbegriff für die Familien- und Ahnenforschung und beschäftigt sich mit der historischen Herkunft und der Geschichte von Menschen weltweit \cite{AhnenforschungDE}. Dabei sind insbesondere Abstammungs- und Verwandtschaftsverhältnisse von besonderer Bedeutung, die anhand von Beiweisen aus validen Quellen in Stammbäumen zusammengefasst werden, die aufzeigen, wie eine Generation mit der nächsten verbunden ist. Auf Basis der so erlangten Erkenntnisse kann eine Familiengeschichte erstellt werden, die eine biographische Studie einer genealogisch nachgewiesenen Familie und der Gemeinde in der sie lebten, darstellt \cite{SocietyOfGenealogists}.

Das Aufkommen des Internets stellte einen Wendepunkt in der Genealogie dar. Die einfachere Kommunikation auch über Landesgrenzen hinweg, ermöglicht es genealogische Informationen auszutauschen und so Gleichgesinnte und Verwandte auf der ganzen Welt zu finden \cite{AhnenforschungDE}. Um einen standardisierten Austausch genalogischer Informationen zu ermöglichen, entwickelte die Kirche Jesu Christi der Heiligen der Letzten Tage das Datenformat GEDCOM, das im folgenden Kapitel vorgestellt wird.
\newpage
\section{GEDCOM Version 7}
{
\label{sec: GEDCOM Version 7}
Das Datenformat FamilySearch GEDCOM 7.0 ist ein einheitliches, flexibles Format für den Austausch von genealogischen Daten, das 2021 von der Kirche Jesu Christi der Heiligen der Letzten Tage entwickelt wurde. Das Ziel besteht darin, eine langfristige Speicherung von genealogischen Informationen zu ermöglichen, die für zukünftige Genealogen und die von ihnen verwendeten System zugänglich und verständlich sind \cite{GEDCOM}. Die im Rahmen dieser Arbeit verwendete Version 7.0.11 wurde am 01.11.2022 veröffentlicht und stellt die aktuelleste Version des Standards dar\footnote{Stand 31.01.2023}. 

GEDCOM ist ein UTF-8 kodiertes hierarchisches Containerformat, das die Dateinamenserweiterung \textit{.ged} verwendet. Der erste Character einer GEDCOM-Datei sollte das Byte-Order-Mark (U+FEFF) sein. Der Inhalt einer GEDCOM-Datei ist in sog. \textit{Structures} unterteilt, die aus einem \textit{Structure-Type} und einem optionalen \textit{Payload} bestehen und mehrere Substrukturen besitzen können. Hat eine \textit{Structure} eine \textit{Substructure}, dann ist die \textit{Structure} die \textit{Superstructure} der \textit{Structure}. Jede \textit{Substructure} hat genau eine \textit{Superstructure} und ist so eindeutig zugeordnet. Eine \textit{Structure}, die keine \textit{Supertructure} besitzt, heißt \textit{Record}. Alle Records zusammen mit einem Header und einem Trailer bilden ein \textit{Dataset}, das den Inhalt einer GEDCOM-Datei darstellt. \cite{GEDCOM} 

Der \textit{Payload} einer \textit{Structure} ist eine Zeichenkette eines bestimmten Datentyps, die entweder Informationen für die \textit{Supertructure} bereithält, oder einen Zeiger auf eine andere \textit{Structure} repräsentiert und somit auf diese verweist. GEDCOM v7 definiert 11 verschiedene Datentypen in \cite{GEDCOM} mit denen Namen, Daten, Uhrzeiten, Texte und vieles mehr dargestellt werden können. Der \textit{Structure-Type} ist eindeutig definiert durch eine URI und gibt an, welche Bedeutung und welchen Datentyp die \textit{Structure} besitzt, welche \textit{Substructures} enthalten sein können und mit welcher Kardinalität diese auftreten können. \cite{GEDCOM} 

Kodiert wird der Inhalt einer GEDCOM-Datei in sog. \textit{Lines}, die eine Zeichenkettenrepräsentation einer \textit{Structure} (bzw. eines Teils einer \textit{Structure}) darstellen und wie in Listing \ref{lst: gedcom line} aufgebaut sind. Die Bedeutung der einzelnen Bestandteile einer Line ist in Tabelle \ref{tab: gedcom line} spezifiziert.
\vspace{1em}
\begin{lstlisting}
	Level  D  [Xref  D]  Tag  [D  LineVal]  EOL
\end{lstlisting}
\captionof{lstlisting}{Aufbau einer GEDCOM Line. Eckige Klammern repräsentieren optionale Inhalte.}
\label{lst: gedcom line}
\newpage
\bgroup
\def\arraystretch{1.5}%  1 is the default, change whatever you need
\setlength{\tabcolsep}{18pt}
\begin{longtable}{|p{2cm}|p{10cm}|}
	\hline
	\textbf{URI} & Eine Line beginnt mit einem Level, das die Verhältnisse der \textit{Structures} untereinander beschreibt. Alle \textit{Structures} mit dem kleinstmöglichen Level $0$ sind Records - Level $\ge1$ repräsentieren \textit{Substructures}. Eine \textit{Structure} mit dem Level $x$ ist also die \textit{Superstructure} aller folgenden \textit{Structures} mit dem Level $x+1$. \\
	\hline
	\textbf{D} & \textit{D} steht für \textit{Delimiter}, was englisch für Trennzeichen ist und repräsentiert in diesem Fall das Leerzeichen mit dem Unicode $u+0020$. \\
	\hline
	\textbf{Xref} & Xref ist die Abkürzung für \textit{Cross-Reference Identifier} und fungiert als Adresse für eine \textit{Structure}. Möchte man von einer \textit{Structure} auf eine andere \textit{Structure} verweisen, kann dies über einen Zeiger-Payload auf die entsprechende \textit{Structure} realisiert werden.\\
	\hline
	\textbf{Tag} & Der \textit{Tag} kodiert den \textit{Structure-Type} einer \textit{Structure}.\\
	\hline
	\textbf{LineVal} & Im \textit{LineVal} einer Struktur ist der Payload kodiert.\\
	\hline
	\textbf{EOL} & EOL steht für End-Of-Line und kodiert das Ende einer Line. Im Format GEDCOM v7 kann dies entweder durch einen Carriage-Return (Unicode U+000D), Line-Feed(Unicode U+000A) oder einen Carriage-Return gefolgt von einem Line-Feed repräsentiert werden.\\
	\hline
	\caption{Bestandteile einer GEDCOM Line und ihre Bedeutung} % needs to go inside longtable environment
	\label{tab: gedcom line}
\end{longtable}
\egroup
\vspace{1em}
Ein Ausschnitt aus einer GEDCOM-Datei ist in Listing \ref{lst: family record example} dargestellt. Dieser Ausschnitt zeigt einen \textit{Record} vom Typ \textit{Family}, in dem Informationen über eine Familie gespeichert werden können. Der Familie wurde der Cross-Reference Identifier \textit{@F1@} zugewiesen, sodass im Dataset auf dieses verwiesen werden kann. Der Ehemann und die Ehefrau der Familie (engl. Husband und Wife) sind die Individuen \textit{I1} und \textit{I2}, die ebenfalls in der Gedcom7-Datei definiert sind. Dieser Zusammenhang wird über die Cross-Reference Identifier \textit{@I1@} und \textit{@I2@} ausgedrückt. Außerdem wird ein Family-Event, nämlich die Hochzeit der beiden Ehepartner, aufgeführt und auf den 1.März 1951 datiert. Als letzte Information ist die Anzahl der Kinder (NCHI: Number of Children) mit 2 spezifiziert.
\newpage
\begin{lstlisting}
	0 @F1@ FAM
	1 HUSB @I1@
	1 WIFE @I2@
	1 MARR
	2 DATE 1 MAR 1951
	1 NCHI 2
\end{lstlisting}
\captionof{lstlisting}{Beispiel für einen Family Record}
\label{lst: family record example}
\vspace{1em}
Detaillierte Erklärungen, alle Informationen zu \textit{Structure Types}, Datentypen, usw. und viele weitere Beispiele können in \cite{GEDCOM} nachgelesen werden.
}
\section{Nearley}
\label{sec: Nearley}
% TO-DO: EBNF erklären bzw. einmal ansprechen -> vielleicht schon im Gedcom-Kapitel?
Nearley.js ist eine JavaScript-Bibliothek zum Parsen kontextfreier Grammatiken (CFGs). Sie bietet einen vielseitigen und effizienten Parsing-Algorithmus, 
der auf dem Algorithmus von Earley basiert und es ermöglicht, mehrdeutige und rekursive Grammatiken mit Leichtigkeit zu behandeln. Die Bibliothek ist 
modular aufgebaut, so dass Benutzer ihre eigenen Parser und Lexer definieren und Parser aus externen Quellen wie BNF- und EBNF-Grammatiken erzeugen können. 
Nearley.js ist in reinem JavaScript implementiert und kann in jeder Umgebung ausgeführt werden, die JavaScript unterstützt, einschließlich Webbrowsern und 
serverseitigen Umgebungen.


Nearley.js bietet eine Reihe nützlicher Funktionen, darunter JavaScript-Aktionen, genannt \textit{Postprocessor}, bei denen Benutzer Code angeben können, 
der ausgeführt wird, wenn bestimmte Teile der Eingabe erkannt werden. Nearley.js ist Open-Source und hat eine lebendige Gemeinschaft von Nutzern und 
Mitwirkenden, was es zu einem zuverlässigen und gut unterstützten Werkzeug für das Parsen komplexer Texte macht.


Im Laufe der Implementierung haben wir uns dazu entschieden, die komplette GEDCOM-Grammatik mittels Nearley abzubilden. Dies hat den Vorteil, dass wir 
alle Regeln der GEDCOM-Spezifikation in einer Prüfung abdecken können. Außerdem bietet Nearley die Möglichkeit Teile der Grammatik in einzelnen Dateien
auszulagern und nur für Teile der Grammatik Parser zu erstellen. Dies ermöglicht es uns eine Teilprüfung von nur einer GEDCOM-Struktur einer
ganzen Datei durchzuführen. Dies ist insbesondere bei Manipulationen von einzelnen Strukturen innerhalb einer Datei von Vorteil, da anschließend
nur die betroffene Struktur neu geprüft werden muss.

% TO-DO: Beispiel einer Nearley Grammatik einfügen und erklären

\section{Mocha}
\label{sec: Mocha}

Im Rahmen der Implementierung unserer Bibliothek, war es uns ein zentrales Anliegen, das Testen dieser zu gewährleisten. Zu diesem Zweck haben wir uns auf die Suche nach einem geeigneten Testframework für JavaScript begeben. In diesem Kontext stießen wir auf Mocha, welches eine API bereitstellt, die das einfache Erstellen von Tests ermöglicht. Wie bei vielen anderen Testframeworks können Assertion-Funktionen genutzt werden, um die Tests zu überprüfen.

Wie im Beispiel-Test in Listing \ref{lst: mocha example} veranschaulicht wird, wird zunächst ein aussagekräftiger Name für den Test als erster Parameter der Mocha-Funktion \textit{describe} übergeben. Im zweiten Parameter wird eine Callback-Funktion übergeben, die den Code für den Test enthält, beginnend mit dem Setup-Code. Hierbei wird in unserem Fall ein Array mit mehreren Gedcom-Dateinamen erstellt, die sich im angegebenen \textit{path} befinden.

Durch die Verwendung der Funktion \textit{forEach}, welche aus einem Mocha-Plugin namens \textit{mocha-each} stammt, wird über alle Dateinamen iteriert. Für jeden Dateinamen wird ein neuer Test erstellt und der Code in der anonymen Callback-Funktion für jeden \textit{fileName} im Array \textit{gedFiles} ausgeführt.

Der Ablauf für eine Datei im Listing \ref{lst: mocha example} ist wie folgt: Zunächst wird die Datei mithilfe der asynchronen Helper-Funktion \textit{readGedFile} eingelesen und in der Variable \textit{beforeParsing} gespeichert. Anschließend wird die Datei mit der Funktion \textit{parseString} des Moduls \textit{gedcomParser} als Dataset geparst. Hierbei wird eine Grammatikprüfung durchgeführt und alle Daten aus der Datei sind nach erfolgreicher Prüfung über die Dataset Klasse und deren Methoden zugänglich.

Im nächsten Schritt wird im aktuellen Verzeichnis eine temporäre Datei namens \textit{temp.ged} erstellt und anschließend mit der Funktion 
\textit{dataset.write} mit den eingelesenen Daten des Datasets beschrieben.

Schließlich wird mithilfe der Funktion \textit{expect}, welche aus dem Mocha-Plugin \textit{chai} stammt, überprüft, ob die eingelesene 
Datei und das geschriebene Dataset in der \textit{temp.ged} Datei identisch sind.
\\\\
Der beschriebene Testmechanismus gewährleistet, dass die Daten, die aus einer GEDCOM-Datei gelesen werden, bei erfolgreichem Parsen nach 
Schreiben ohne Manipulation am Dataset weiterhin identisch und konsistent sind.
\\\\
\begin{javascript}{Beispiel für einen Mocha-Test}{lst: mocha example}
  // GEDCOM READING AND WRITING TEST
  describe('test if gedcom file is equivalent before and after parsing', () => {
  	const path = 'test/sampleData/ExampleFamilySearchGEDCOMFiles/';
  	//correct files
  	const gedFiles = [
		'escapes.ged',
		'long-url.ged',
		'maximal70_without_extensions.ged',
		'minimal70.ged',
		'remarriage1.ged',
		'same-sex-marriage.ged',
		'voidptr.ged'
  	];

  	forEach(gedFiles)
		.it('#%s', async (fileName) => {
	  	// read Gedcom file as String
	  	const beforeParsing = await readGedFile(path + fileName);
	  	// parse Gedcom String and write it to temp.ged
	  	const dataset = gedcomParser.parseString(beforeParsing);
	  	await fs.writeFile(path + 'temp.ged', '');
	  	await dataset.write(path + 'temp.ged');
	  	// read temp.ged as String and compare it with original file
	  	const afterParsing = await readGedFile(path + 'temp.ged');
	  	// expect files to be equal
	  	expect(diffChars(beforeParsing, afterParsing)).to.have.lengthOf(1);
	});
  });
\end{javascript}
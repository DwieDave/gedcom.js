\chapter{Theoretische Grundlagen}
\label{chap: Theoretische Grundlagen}
In diesem Kapitel...

\section{Genealogie und FamilySearch}
\label{sec: Genealogie und FamilySearch}
Genealogie ist ein Überbegriff für die Familien- und Ahnenforschung und beschäftigt sich mit der historischen Herkunft und der Geschichte von Menschen weltweit \cite{AhnenforschungDE}. Dabei sind insbesondere Abstammungs- und Verwandtschaftsverhältnisse von besonderer Bedeutung, die anhand von Beiweisen aus validen Quellen in Stammbäumen zusammengefasst werden, die aufzeigen, wie eine Generation mit der nächsten verbunden ist. Auf Basis der so erlangten Erkenntnisse kann eine Familiengeschichte erstellt werden, die eine biographische Studie einer genealogisch nachgewiesenen Familie und der Gemeinde in der sie lebten, darstellt \cite{SocietyOfGenealogists}.

Das Aufkommen des Internets stellte einen Wendepunkt in der Genealogie dar. 

\section{GEDCOM Version 7}
\label{sec: GEDCOM Version 7}
Das Datenformat FamilySearch GEDCOM 7.0 wurde 2021 von der Kirche Jesu Christi der Heiligen der Letzten Tage entwickelt und stellt ein einheitliches, flexibles Format für den Austausch von genealogischen Daten bereit. Das Ziel besteht darin, eine langfristige Speicherung von genealogischen Informationen zu ermöglichen, die für zukünftige Genealogen und die von ihnen verwendeten System zugänglich und verständlich ist \cite{GEDCOM}. Die im Rahmen dieser Arbeit verwendete Version 7.0.11 wurde am 01.11.2022 veröffentlicht und stellt die aktuelleste\footnote{Stand 31.01.2023} Version des Standards dar. 

GEDCOM ist ein UTF-8 kodiertes hierarchisches Containerformat, das die Dateinamenserweiterung \textit{.ged} verwendet. Der erste Character einer GEDCOM-Datei sollte das Byte-Order-Mark (U+FEFF) sein. Der Inhalt einer GEDCOM-Datei ist in sog. \textit{Structures} unterteilt, die aus einem \textit{Structure Type} und einem optionalen \textit{Payload} bestehen und mehrere Substrukturen besitzen können. Hat eine \textit{Structure} eine \textit{Substructure}, dann ist die \textit{Structure} die \textit{Superstructure} der \textit{Structure}. Jede \textit{Substructure} hat genau eine \textit{Superstructure} und ist so in der Gesamtstruktur eindeutig zugeordnet. Eine \textit{Structure}, die keine \textit{Supertructure} besitzt, heißt \textit{Record}. Alle Records zusammen mit einer \textit{Header}- und einer \textit{Trailer}-Struktur bilden ein \textit{Dataset}, das den Inhalt einer GEDCOM-Datei darstellt. \cite{GEDCOM} 

Der \textit{Payload} einer \textit{Structure} ist eine Zeichenkette eines bestimmten Datentyps, die entweder Informationen für die \textit{Supertructure} bereithält, oder einen Zeiger auf eine andere \textit{Structure} repräsentiert und somit auf diese verweist. GEDCOM v7 definiert 11 verschiedene Datentypen in \cite{GEDCOM} mit denen Namen, Daten, Uhrzeiten, Texte und vieles mehr dargestellt werden können. Der \textit{Structure Type} ist eindeutig definiert durch eine URI und gibt an, welche Bedeutung und welchen Datentyp die \textit{Structure} besitzt, welche \textit{Substructures} enthalten sein können und mit welcher Kardinalität diese auftreten können. \cite{GEDCOM} 

Kodiert wird der Inhalt einer GEDCOM-Datei in sog. \textit{Lines}, die eine Zeichenkettenrepräsentation einer Struktur (bzw. eines Teils einer Struktur) darstellen und wie folgt aufgebaut sind (eckige Klammern repräsentieren optionale Inhalte):
\begin{center}
	Level  D  [Xref  D]  Tag  [D  LineVal]  EOL
\end{center}
\begin{itemize}
	\item Level: Eine Line beginnt mit einem Level, das die Verhältnisse der \textit{Structures} untereinander beschreibt. Alle \textit{Structures} mit dem kleinstmöglichen Level $0$ sind Records - Level $\ge1$ repräsentieren \textit{Substructures}. Eine \textit{Structure} mit dem Level $x$ ist also die \textit{Superstructure} aller folgenden \textit{Structures} mit dem Level $x+1$.
	\item D: \textit{D} steht für \textit{Delimiter}, was englisch für Trennzeichen ist und repräsentiert in diesem Fall das Leerzeichen mit dem Unicode $u+0020$.
	\item Xref: Xref ist die Abkürzung für \textit{Cross-Reference Identifier} und fungiert als Adresse für eine \textit{Structure}. Möchte man von einer \textit{Structure} auf eine andere \textit{Structure} verweisen, kann dies über einen Zeiger-Payload auf die entsprechende \textit{Structure} realisiert werden.
	\item Tag: Der \textit{Tag} kodiert den \textit{Structure Type} einer \textit{Structure}.
	\item LineVal: Im \textit{LineVal} einer Struktur ist der Payload kodiert.
	\item EOL: EOL steht für End-Of-Line und kodiert das Ende einer Line. Im Format GEDCOM v7 kann dies entweder durch einen Carriage-Return (Unicode U+000D), Line-Feed(Unicode U+000A) oder einen Carriage-Return gefolgt von einem Line-Feed repräsentiert werden.
\end{itemize}
Ein Ausschnitt aus einer GEDCOM-Datei ist in \ref{lst: family record example} dargestellt. Dieser Ausschnitt zeigt einen \textit{Record} vom Typ \textit{Family}, in dem Informationen über eine Familie gespeichert werden können. Der Familie wurde der Cross-Reference Identifier \textit{@F1@} zugewiesen, sodass im Dokument auf dieses verwiesen werden kann. Der Ehemann und die Ehefrau der Familie (engl. Husband und Wife) sind die Individuen \textit{I1} und \textit{I2}, die ebenfalls in der Gedcom7-Datei definiert sind. Dieser Zusammenhang wird über die Cross-Reference Identifier \textit{@I1@} und \textit{@I2@} ausgedrückt. Außerdem wird ein Family-Event, nämlich die Hochzeit der beiden Ehepartner aufgeführt und auf den 1.März 1951 datiert. Als letzte Information ist die Anzahl der Kinder (NCHI: Number of Children) mit 2 spezifiziert.
\\ \\
\begin{minipage}{1.0\textwidth} \small
	\begin{lstlisting}
		0 @F1@ FAM
		1 HUSB @I1@
		1 WIFE @I2@
		1 MARR
		2 DATE 1 MAR 1951
		1 NCHI 2
	\end{lstlisting}
	\captionof{lstlisting}{Beispiel für einen Family Record}
	\label{lst: family record example}
\end{minipage}
\\ \\
Detaillierte Erklärungen, alle Informationen zu \textit{Structure Types}, Datentypen, usw. und viele weitere Beispiele können in \cite{GEDCOM} nachgelesen werden.

% IDEE: Hier die Spezifikation vom Family Record aufführen und erklären. Dazu vielleicht von einer Substructure und sagen dass so die gesamte Spezifikation aufgebaut ist. Dann ein Beispiel einer Family und darauf in Konzept eingehen. Und am Beispiel dieser Family dann in Implementierung die Convinience Funktionen zeigen

\section{Nearley}
\label{sec: Nearley}
% TO-DO: EBNF erklären bzw. einmal ansprechen -> vielleicht schon im Gedcom-Kapitel?
\subsection*{Allgemeines}
Nearley.js ist eine JavaScript-Bibliothek zum Parsen kontextfreier Grammatiken (CFGs). Sie bietet einen vielseitigen und effizienten Parsing-Algorithmus, 
der auf dem Algorithmus von Earley basiert und es ermöglicht, mehrdeutige und rekursive Grammatiken mit Leichtigkeit zu behandeln. Die Bibliothek ist 
modular aufgebaut, so dass Benutzer ihre eigenen Parser und Lexer definieren und Parser aus externen Quellen wie BNF- und EBNF-Grammatiken erzeugen können. 
Nearley.js ist in reinem JavaScript implementiert und kann in jeder Umgebung ausgeführt werden, die JavaScript unterstützt, einschließlich Webbrowsern und 
serverseitigen Umgebungen.

Nearley.js bietet eine Reihe nützlicher Funktionen, darunter JavaScript-Aktionen, genannt \textit{Postprocessor}, bei denen Benutzer Code angeben können, 
der ausgeführt wird, wenn bestimmte Teile der Eingabe erkannt werden. Nearley.js ist Open-Source und hat eine lebendige Gemeinschaft von Nutzern und 
Mitwirkenden, was es zu einem zuverlässigen und gut unterstützten Werkzeug für das Parsen komplexer Texte macht.

\subsection*{Grammatik}
Im Laufe der Implementierung haben wir uns dazu entschieden, die komplette GEDCOM-Grammatik mittels Nearley abzubilden. Dies hat den Vorteil, dass wir 
alle Regeln der GEDCOM-Spezifikation in einer Prüfung abdecken können. Außerdem bietet Nearley die Möglichkeit Teile der Grammatik in einzelnen Dateien
auszulagern und nur für Teile der Grammatik Parser zu erstellen. Dies ermöglicht es uns eine Teilprüfung von nur einer GEDCOM-Struktur einer
ganzen Datei durchzuführen. Dies ist insbesondere bei Manipulationen von einzelnen Strukturen innerhalb einer Datei von Vorteil, da anschließend
nur die betroffene Struktur neu geprüft werden muss.

\subsection*{Beispiel}

% TO-DO: Beispiel einer Nearley Grammatik einfügen und erklären

\section{Mocha}
\label{sec: Mocha}

Im Rahmen der Bibliotheksimplementierung, war es ein zentrales Anliegen, das Testen dieser zu gewährleisten.
Zu diesem Zweck musste ein geeignetes JavaScript-Testframework gefunden werden. Mocha ist für diesen Einsatz geeignet, da es eine API bereitstellt, 
die das einfache Erstellen von Tests ermöglicht. Wie bei vielen anderen Testframeworks können Assertion-Funktionen genutzt werden, um die Tests zu überprüfen. 
Hierbei bietet Mocha die Möglichkeit, verschiedene Assertion-Frameworks zu nutzen. In diesem Projekt wurde das Framework \textit{Chai} verwendet.
\\\\
Ein einfaches Beispiel für einen Mocha-Test mit Chai-Assertion ist in Listing \ref{lst: mocha example} dargestellt. Es wird lediglich überprüft ob der Wert der Konstante
\textit{value} gleich ihrem zugewiesenem Wert 1 ist.
Die Funktion \textit{expect().to.equal()} stammt aus der Chai-Bibliothek und überprüft ob der Parameter der Funktion \textit{expect()} dem Parameter der \textit{equal()} Funktion entspricht.


\begin{javascript}{Beispiel für einen Mocha-Test}{lst: mocha example}
	describe('test example', function () {
		it('should assert true', function (done) {
			const value = 1;
			expect(value).to.equal(1);
			done();
		});
	});
\end{javascript}